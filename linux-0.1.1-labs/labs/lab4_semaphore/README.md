# 信号量的实现和应用
## 课程说明
本实验是 操作系统之进程与线程 - 网易云课堂 的配套实验，推荐大家进行实验之前先学习相关课程：

- L16 进程同步与信号量
- L17 对信号量的临界区保护
- L18 信号量的代码实现
- L19 死锁处理

Tips：点击上方文字中的超链接或者输入 https://mooc.study.163.com/course/1000002008#/info 进入理论课程的学习。 如果网易云上的课程无法查看，也可以看 Bilibili 上的 操作系统哈尔滨工业大学李治军老师。

## 实验目的
- 加深对进程同步与互斥概念的认识；
- 掌握信号量的使用，并应用它解决生产者——消费者问题；
- 掌握信号量的实现原理。
## 实验内容
本次实验的基本内容是：

- 在 Ubuntu 下编写程序，用信号量解决生产者——消费者问题；
- 在 0.11 中实现信号量，用生产者—消费者程序检验之。
### 3.1 用信号量解决生产者—消费者问题
在 Ubuntu 上编写应用程序“pc.c”，解决经典的生产者—消费者问题，完成下面的功能：

建立一个生产者进程，N 个消费者进程（N>1）；
用文件建立一个共享缓冲区；
生产者进程依次向缓冲区写入整数 0,1,2,...,M，M>=500；
消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程 ID 和 + 数字输出到标准输出；
缓冲区同时最多只能保存 10 个数。
一种可能的输出效果是：
```
10: 0
10: 1
10: 2
10: 3
10: 4
11: 5
11: 6
12: 7
10: 8
12: 9
12: 10
12: 11
12: 12
……
11: 498
11: 499
```
其中 ID 的顺序会有较大变化，但冒号后的数字一定是从 0 开始递增加一的。

`pc.c` 中将会用到 `sem_open()`、`sem_close()`、`sem_wait()` 和 `sem_post()` 等信号量相关的系统调用，请查阅相关文档。

### 3.2 实现信号量
```
sem_t *sem_open(const char *name, unsigned int value);
int sem_wait(sem_t *sem);
int sem_post(sem_t *sem);
int sem_unlink(const char *name);
```
- `sem_open()` 的功能是创建一个信号量，或打开一个已经存在的信号量。
  - `sem_t` 是信号量类型，根据实现的需要自定义。
  - `name` 是信号量的名字。不同的进程可以通过提供同样的 name 而共享同一个信号量。如果该信号量不存在，就创建新的名为 name 的信号量；如果存在，就打开已经存在的名为 name 的信号量。
  - `value` 是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。当成功时，返回值是该信号量的唯一标识（比如，在内核的地址、ID 等），由另两个系统调用使用。如失败，返回值是 NULL。
- `sem_wait()` 就是信号量的 P 原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量 sem 上。返回 0 表示成功，返回 -1 表示失败。
- `sem_post()` 就是信号量的 V 原子操作。如果有等待 sem 的进程，它会唤醒其中的一个。返回 0 表示成功，返回 -1 表示失败。
- `sem_unlink()` 的功能是删除名为 name 的信号量。返回 0 表示成功，返回 -1 表示失败。

在 kernel 目录下新建 sem.c 文件实现如上功能。然后将 pc.c 从 Ubuntu 移植到 0.11 下，测试自己实现的信号量。
