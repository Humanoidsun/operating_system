0、未修改前的代码fork时，需要拷贝内核栈吗？不拷贝的话，为什么？拷贝的话，代码在哪里?

不拷贝，因为未修改前的代码在switch时直接通过tss转换到新进程，而在fork时tss中填写的cs ip 直接为用户态的代码段，因此switch将直接将新进程转换到用户态。
而修改后的代码由于不能通过tss恢复寄存器的值，故需要通过first_run_after_fork来恢复寄存器的值。


1、针对下面的代码片段：

movl tss,%ecx
addl $4096,%ebx
movl %ebx,ESP0(%ecx)
回答问题：

（1）为什么要加 4096；

答：4096=4kB，在linux0.11中，一个进程的内核栈和该进程的PCB段是放在一块大小为4KB的内存段中的，其中该内存段的高地址开始是内核栈，低地址开始是PCB段。ebx是指向一个进程的PCB，偏移4096后便指向了另一个进程的PCB.栈结构如下：

在这里插入图片描述

（2）为什么没有设置 tss 中的 ss0。

SS0、SS1和SS2分别是0、1和2特权级的栈段选择子。这里用不着特权级为0的内核段。此时唯一的tss的目的就是:在中断处理时，能够找到当前进程的内核栈的位置。

2、针对下面代码片段

*(--krnstack) = ebp;
*(--krnstack) = ecx;
*(--krnstack) = ebx;
*(--krnstack) = 0;
回答问题

1、子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？

eax = 0;其实就是将内核栈用用于返回给eax寄存器的内容置为0，最后eax的内容会返回给fork函数

2、这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？

答：ebx和ecx来自copy_process()的形参，形参的来源是各个段寄存器。对于fork函数而言，子进程是父进程的拷贝，就是要让父子进程共用同一个代码、数据和堆栈。

3、这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？

ebp是用户栈地址，一定要设置，不设置子进程就没有用户栈了。
