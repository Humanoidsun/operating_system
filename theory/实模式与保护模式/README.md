# 实模式和保护模式是什么
## 实模式
实模式出现于早期8088CPU时期，当时的操作系统很简单，大多数都是用在一个固定用途的机器上，即使是当时所谓的通用计算机，程序也大多都是使用这个机器的人来进行编写，很少有现在的一个机器上跑着到处下载来的应用，因此当时操作系统的需求很简单，能提供基本的功能就行，不太要求多个应用之间的隔离性和安全性等。所以那个时候的所有的应用的寻址方式都是一样的，都可以访问到任意物理地址的空间("实"指的大概就是这个)，它的寻址方式如下：

> 物理地址 = 段基址(cs、ds、ss、es等段寄存器)<<4 + 段内偏移(ip、di、si、bp、sp等寄存器)

之所以使用 `段基址<<4 + 段内偏移`的计算方式，大概有两个原因：
- **在硬件层面上提供 代码段、数据段、堆栈段 的分离，便于程序员分离(分段)管理这些数据，大大减少其工作量，简化其工作**。使用久了高级语言的程序员或许会觉得，分离这些东西有什么用，自己分离不就行了，但是让我们来想一想，如果CPU在硬件层面不提供这些，我们自己要分离管理这些数据的话，要怎么做呢？CPU可不能提供 List、Map 这些数据结构。是不是还挺复杂的，**即使有解决方案，性能上肯定也比不过使用 段寄存器 来直接进行分段管理**。
- **扩展地址空间**：如果仅仅使用一个16位的寄存器来进行访问地址空间，那么地址空间只有16位，这个地址空间的大小即使在那个时代，也显得很小，甚至有些许不够用。因此当时使用`段基址<<4 + 段内偏移`的方式来扩展内存的地址空间，将其扩展到了 20 位，对应的大小为`1MB`。也许你会觉得`1MB`也太小了吧，但是在当时`1MB`可是很多人梦寐以求的大小。其价格接近上万美元(那个时候的1万美元和现在可不一样)。

![存储价格](README.assets/price_of_memory.png)
## 保护模式
为了让计算机可以进一步发展，让用户可以安全地下载并使用任何地方来的应用程序，这个时候对操作系统提出了更高的要求，即：需要保证多个应用之间的相互独立及安全性，且用户程序无法破环操作系统的数据(这样即使某个应用程序是恶意软件，也不会影响操作操作系统的代码(除非操作系统自己有漏洞)，只要用户重启就可以解决大多数问题(所以遇到问题，先重启试试^-^))，这就要求**多个应用之间的数据都进行隔离，一个应用无法访问另一个应用的数据**。

要实现上面这个需求，有下面俩种方式实现：

- 操作系统发现这个应用访问其它地址时，直接报错。——  操作系统需要在运行或者启动时对每一个访存指令进行检查，性能低下。
- 在CPU层面不允许当前应用访问其它应用的地址。—— 保护模式，性能更高，也更加灵活。

为了实现这个目的，寻址方式必须进行改变，不能再继续使用实模式的`物理地址 = 段基址<<4 + 段内偏移`的方式进行寻址，而是提出了保护模式这种新的模式，这个模式的目的如其名就是为了"保护"，这种模式下的寻址方式使用的是下面的段页结合的方式进行寻址：


![保护模式寻址](README.assets/protect_mode_address.png)


看起来要比实模式复杂得多，确实，新的模式尽管很好，但也的确引入了很大的复杂度，不过一切的设计都是很合理的，下面我们来具体分析分析一下上面这个图：
## 为什么要使用虚拟内存


## 为什么要段页结合的方式进行寻址
### 为什么要分段
#### 分段的好处
这个问题上面已经回答过了，这里再来抄一遍：
> **在硬件层面上提供 代码段、数据段、堆栈段 的分离，便于程序员分离(分段)管理这些数据，大大减少其工作量，简化其工作**。使用久了高级语言的程序员或许会觉得，分离这些东西有什么用，自己分离不就行了，但是让我们来想一想，如果CPU在硬件层面不提供这些，我们自己要分离管理这些数据的话，要怎么做呢？CPU可不能提供 List、Map 这些数据结构。是不是还挺复杂的，**即使有解决方案，性能上肯定也比不过使用 段寄存器 来直接进行分段管理**。

因为32位操作系统的地址空间已经足够了，因此这里没有扩展地址空间的作用。
#### 为什么不直接使用分页
访问一个段的数据，对于汇编程序员来说很容易(使用 `段基址:段内偏移` 就可以实现) ，但是如果访问页的数据对于汇编程序员来说过于复杂，如：

- 访问代码段：`cs:eip`  这样就可以访问代码段，如果让程序员用页的方式去访问，你能想到怎么搞吗? 要每次访问都要自己去写管理页的代码吗? 想想就很复杂

### 为什么要分页
如果仅仅只有分段的话，且要实现内存保护功能(靠虚拟内存实现)的话，有下面两种方式：

> - 内存分配以段为单位，物理内存中保存用户虚拟段到物理实际段之间的映射关系。—— 缺点：段的空间过大，以段为单位进行内存分配，容易导致产生很多内存碎片，从而是的内存利用率较低。
> - 内存分配以每个地址为单位，物理内存中保存用户虚拟内存到物理实际内存之间的映射关系。—— 缺点：虚拟内存与实际内存一一对应，这样虚拟内存到实际内存的映射表的大小将会和物理内存本身一样大，也就是说所有的内存都会用来存放这张映射表，因此也无法实现。

通过对上面两种情况进行分析，我们会发现：

> - **以段为单位进行内存分配，容易导致产生很多内存碎片，从而使得内存利用率较低**。
> - **以每个地址为单位进行内存分配**，会导致整个物理内存都用来存放虚拟内存到物理内存的映射表，即**映射表太大**。

那么有没有一种方式，即能使**内存利用率高**，又可以使得**虚拟内存到物理内存之间的映射表不至于太大**。 没错，这种方案就是**分页**：

- 内存分配以页为单位，通常一页大小为`4KB`，物理内存中保存虚拟页到实际页之间的映射关系。

这样设计将会使得内存的利用率比以段为单位分配内存高很多，虚拟页与实际页之间的映射表也会比虚拟地址到实际地址之间的映射表小很多。因此，操作系统的最终设计使用了分页来进行内存分配。

#### 为什么要多级分页
紧接着上一个小节，


### 结论 
之所以使用段页结合的方式来进行内存管理，是因为：

> - 面向程序员使用分段的方式，**硬件层面提供数据分离**，可以使程序员**更容易**地写出**性能更高**代码。
> - 面向物理内存使用分页的方式，既能提高物理内存的利用率，又可以使得虚拟内存到物理内存之间的映射表占用的物理内存大大减小。

因此，操作系统最终采用段页结合的方式来进行内存管理。
# GDT

## GDTR

## GDT 表项

## GDT 初始化代码

# LDT

## LDTR

## LDT 表项

## LDT 初始化代码

# 如何切换至保护模式

## linux 0.1.1 中如何实现切换至保护模式

# 保护模式如何访存

## 用户态如何访存

## 内核态如何访存

### 如何访问用户空间

### 如何访问内核空间

### 如何在用户空间与内核空间传递数据
