# 实模式和保护模式是什么
## 实模式
实模式出现于早期8088CPU时期，当时的操作系统很简单，也没有应用之间的隔离，因此所有的应用的寻址方式都是一样的，且都可以访问到任意物理地址的空间("实"值得大概就是这个)，它的寻址方式如下：

> 物理地址 = 段基址(cs、ds、ss、es等段寄存器)<<4 + 段内偏移(ip、di、si、bp、sp等寄存器)

之所以使用 `段基址<<4 + 段内偏移`的计算方式是因为：如果仅仅使用一个16位的寄存器来进行访问地址空间，那么地址空间只有16位，这个地址空间的大小即使在那个时代，也显得很小，甚至有些许不够用。因此当时使用`段基址<<4 + 段内偏移`的方式来扩展内存的地址空间，将其扩展到了 20 位，对应的大小位`1MB`。也许你会觉得`1MB`也太小了吧，但是在当时`1MB`可是很多人梦寐以求的大小。其价格在上万美元以上。

## 保护模式
随着计算机的发展，对操作系统提出了更高的要求，为了保证多个应用之间的相互独立及安全性，期望**多个应用之间的数据都进行隔离，一个应用无法访问另一个应用的数据**。

要实现上面这个需求，有下面俩种方式实现：

- 操作系统发现这个应用访问其它地址时，直接报错。——  操作系统需要在运行或者启动时对每一个访存指令进行检查，性能低下。
- 在CPU层面不允许当前应用访问其它应用的地址。—— 保护模式，性能更高，也更加灵活。

为了实现这个目的，保护模式的寻址方式也进行了改变，不再使用`物理地址 = 段基址<<4 + 段内偏移`的方式进行寻址，而使用下面的段页结合的方式进行寻址：


![保护模式寻址](README.assets/protect_mode_address.png)


## 为什么要段页结合的方式进行寻址

访问一个段的数据，对于汇编程序员来说很容易(使用 `段基址:段内偏移` 就可以实现) ，但是如果访问页的数据对于汇编程序员来说过于复杂，如：

- 访问代码段：`cs:eip`  这样就可以访问代码段，如果让程序员用页的方式去访问，你能想到怎么搞吗? 反正我是想不到的
- 访问数据段：`ds:bp`  这样就可以访问数据段，如果让程序员用页的方式去访问，这次你能想到怎么搞吗? 反正我还是想不到的

# GDT

## GDTR

## GDT 表项

## GDT 初始化代码

# LDT

## LDTR

## LDT 表项

## LDT 初始化代码

# 如何切换至保护模式

## linux 0.1.1 中如何实现切换至保护模式

# 保护模式如何访存

## 用户态如何访存

## 内核态如何访存

### 如何访问用户空间

### 如何访问内核空间
