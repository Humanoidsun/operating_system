# 操作系统历史
## 1 什么是操作系统
精简的说的话，操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。操作系统所处的位置如下图所示：

![os_loc](README.assets/os_loc.jpg)

操作系统位于计算机硬件与应用软件之间，本质也是一个软件。操作系统由操作系统的内核（运行于内核态，管理硬件资源）以及系统调用（运行于用户态，为应用程序员写的应用程序提供系统调用接口）两部分组成，所以，单纯的说操作系统是运行于内核态的，是不准确的。

### 1.1 操作系统作用
#### 1.1.1 为应用程序提供如何使用硬件资源的抽象。
隐藏了丑陋的硬件调用接口，为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）。应用程序员有了这些接口后，就不用再考虑操作硬件的细节，专心开发自己的应用程序即可。

![os_desc](README.assets/os_desc.jpg)

##### 举例：
操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制。

##### 注意：
> 
> 操作系统提供给应用程序的该抽象是简单，清晰，优雅的。为何要提供该抽象呢？
> 
> 硬件厂商需要为操作系统提供自己硬件的驱动程序（设备驱动，这也是为何我们要使用声卡，就必须安装声卡驱动），厂商为了节省成本或者兼容旧的硬件，它们的驱动程序是复杂且丑陋的。
> 
> 操作系统就是为了隐藏这些丑陋的信息，从而为用户提供更好的接口，这样用户使用的shell，Gnome，KDE看到的是不同的界面，但其实都使用了同一套由linux系统提供的抽象接口


#### 1.1.2 管理硬件资源
现代的操作系统运行同时运行多道程序，操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O接口设备的分配。

##### 举例：
同一台计算机上同时运行三个程序，它们三个想在同一时刻在同一台计算机上输出结果，那么开始的几行可能是程序1的输出，接着几行是程序2的输出，然后又是程序3的输出，最终将是一团糟（程序之间是一种互相竞争资源的过程）

操作系统将打印机的结果送到磁盘的缓冲区，在一个程序完全结束后，才将暂存在磁盘上的文件送到打印机输出，同时其他的程序可以继续产生更多的输出结果（这些程序的输出没有真正的送到打印机），这样，操作系统就将由竞争产生的无序变得有序化。

## 2.为什么要有操作系统
现代的计算机系统主要是由一个或者多个处理器，主存，硬盘，键盘，鼠标，显示器，打印机，网络接口及其他输入输出设备组成。可以看出来现代计算机系统是一个复杂的系统。因此：

- 如果每位应用程序员都必须掌握该系统所有的细节，那就不可能再编写代码了（严重影响了程序员的开发效率：全部掌握这些细节可能需要一万年....）

- 管理这些部件并加以优化使用，是一件极富挑战性的工作，于是，计算安装了一层软件（系统软件），称为操作系统。它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。

##### 总结
程序员无法把所有的硬件操作细节都了解到，管理这些硬件并且加以优化使用是非常繁琐的工作，这个繁琐的工作就是操作系统来干的，有了他，程序员就从这些繁琐的工作中解脱了出来，只需要考虑自己的应用软件的编写就可以了，应用软件直接使用操作系统提供的功能来间接使用硬件。

## 当前操作系统源码
当前，操作系统是一个大型、复杂、长寿的软件：
- 大型：linux或windows的源代码有五百万行数量级。按照每页50行共1000行的书来算，五百万行要有100卷，要用一整个书架子来摆置，这还仅仅是内核部分。

- 长寿：操作系统很难编写，如此大的代码量，一旦完成，操作系统所有者便不会轻易扔掉，再写一个。而是在原有的基础上进行改进。（基本上可以把windows95/98/Me看出一个操作系统，而windows NT/2000/XP/Vista则是两位一个操作系统，对于用户来说它们十分相似。还有UNIX以及它的变体和克隆版本也演化了多年，如System V版，Solaris以及FreeBSD等都是Unix的原始版，不过尽管linux非常依照UNIX模式而仿制，并且与UNIX高度兼容，但是linux具有全新的代码基础）

## 洪荒时代操作系统的发展历程
### 第一代计算机（真空管和穿孔卡片）—— 1940~1955
![computer_1](README.assets/computer_1.jpg)
#### 产生背景：

第一代之前人类是想用机械取代人力，第一代计算机的产生是计算机由机械时代进入电子时代的标志，从Babbage失败之后一直到第二次世界大战，数字计算机的建造几乎没有什么进展，第二次世界大战刺激了有关计算机研究的爆炸性进展。

lowa州立大学的john Atanasoff教授和他的学生Clifford Berry建造了据认为是第一台可工作的数字计算机。该机器使用300个真空管。大约在同时：
- Konrad Zuse在柏林用继电器构建了Z3计算机
- 英格兰布莱切利园的一个小组在1944年构建了Colossus
- Howard Aiken在哈佛大学建造了Mark 1
- 宾夕法尼亚大学的William Mauchley和他的学生J.Presper Eckert建造了ENIAC。

这些机器有的是二进制的，有的使用真空管，有的是可编程的，但都非常原始，设置需要花费数秒钟时间才能完成最简单的运算。

在这个时期，同一个小组里的工程师们，设计、建造、编程、操作及维护同一台机器，所有的程序设计是用纯粹的机器语言编写的，甚至更糟糕，需要通过成千上万根电缆接到插件板上连成电路来控制机器的基本功能。没有程序设计语言（汇编也没有），操作系统则是从来都没听说过。使用机器的过程更加原始，详见下‘工作过程’。

#### 特点：
没有操作系统的概念
所有的程序设计都是直接操控硬件

#### 工作过程：
程序员在墙上的机时表预约一段时间，然后程序员拿着他的插件版到机房里，将自己的插件板接到计算机里，这几个小时内他独享整个计算机资源，后面的一批人都得等着(两万多个真空管经常会有被烧坏的情况出现)。

后来出现了穿孔卡片，可以将程序写在卡片上，然后读入机而不用插件板
#### 优点
首代计算机诞生，可以代替人类做很多复杂的计算工作。
#### 缺点：

浪费计算机资源，一个时间段内只有一个人用。

注意：同一时刻只有一个程序在内存中，被cpu调用执行，如果有10个程序的执行，那么它们就是串行的。

### 第二代计算机（晶体管和批处理系统）—— 1955~1965
![computer_2](README.assets/computer_2.jpg)
#### 产生背景
由于当时的计算机非常昂贵，很自然的人们要想办法减少机时的浪费。通常采用的方法就是批处理系统。
#### 特点：
- 设计人员、生产人员、操作人员、程序人员和维护人员直接有了明确的分工，计算机被锁在专用空调房间中，由专业操作人员运行，这便是‘大型机’。
- 有了操作系统的概念
- 有了程序设计语言：FORTRAN语言或汇编语言，写到纸上，然后穿孔打成卡片，再讲卡片盒带到输入室，交给操作员，然后喝着咖啡等待输出接口
#### 工作过程
![process_of_c2](README.assets/process_of_c2.jpg)
#### 第二代如何解决第一代的问题/缺点：
1. 把一堆人的输入攒成一大波输入，
2. 然后顺序计算（这是有问题的，但是第二代计算也没有解决）
3. 把一堆人的输出攒成一大波输出
#### 优点
- 批处理，节省了机时

#### 缺点：
1. 整个流程需要人参与控制，将磁带搬来搬去（中间俩小人）
2. 计算的过程仍然是顺序计算 -> 串行
3. 程序员原来独享一段时间的计算机，现在必须被统一规划到一批作业中，等待结果和重新调试的过程都需要等同批次的其他程序都运作完才可以（这极大的影响了程序的开发效率，无法及时调试程序）
## 文章来源
> 该文章转载自：[操作系统的发展历史](https://zhuanlan.zhihu.com/p/367996835)
> 
> 作者：       [Drew](https://www.zhihu.com/people/drew-62-16)
## 其他相关历史
- [模拟电路历史](https://www.bilibili.com/video/BV1774114798/?spm_id_from=333.788.recommend_more_video.3&vd_source=afbe39567defad401c79f6fbb57691cf)
- [数字电路历史](https://www.bilibili.com/video/BV1Hi4y1t7zY/?spm_id_from=333.788.recommend_more_video.0&vd_source=afbe39567defad401c79f6fbb57691cf)
- [近代计算机的文艺复兴-冯诺依曼之外](https://www.bilibili.com/video/BV1Uf4y1o7aj?spm_id_from=333.999.0.0&vd_source=afbe39567defad401c79f6fbb57691cf)
